import os
from pprint import pprint
from antipattern_descriptions import error_descriptions
from pattern_data import patterns

class DockerfileNode:
    def __init__(self, instruction, args,user):
        self.instruction = instruction.upper()
        self.args = args
        self.children = []
        self.user = user

    def add_child(self, child):
        self.children.append(child)

    def set_user(self, user):
        self.user = user

def parse_dockerfile(file_path):
    """Parse Dockerfile contents from a file into an AST."""
    if not os.path.exists(file_path):
        raise FileNotFoundError(f"The specified file does not exist: {file_path}")

    with open(file_path, 'r') as file:
        lines = file.readlines()

    user = ''

    root = DockerfileNode('ROOT', '', user)
    it = iter(lines)


    for line in it:
        line = line.strip()
        if line and not line.startswith('#'):
            if line.endswith('\\'):
                # Handle multi-line instructions
                full_instruction = line[:-1].strip()
                while line.endswith('\\'):
                    line = next(it).strip()
                    full_instruction += line[:-1].strip()
                line = full_instruction
            parts = line.split(' ', 1)
            if len(parts) > 1:
                instruction, args = parts[0], parts[1].strip()
                if (instruction == "USER"):
                    user = args
                root.add_child(DockerfileNode(instruction, args, user))
    return root


def check_for_vulnerabilities(node, patterns):
    matches = []
    # Base conditions
    instructions = [child.instruction for child in node.children]
    if 'USER' not in instructions:
        matches.append("Vulnerability found: Container runs as root since there is no USER directive.")
    check_antipatterns(node, patterns, matches)
    return matches
    
def check_antipatterns(node, antipatterns, matches):
    """Recursively check for antipatterns in the Dockerfile AST."""
    
    for antipattern in antipatterns:
        if node.instruction == antipattern['instruction'] and antipattern['args'] in node.args:
            if not 'user' in antipattern:
                matches.append(f"Antipattern found: {error_descriptions[antipattern['errorNo']]}")
            elif antipattern['user'] is False and node.user == '': # Check for user not defined vulnerabilities
                matches.append(f"Antipattern found: {error_descriptions[antipattern['errorNo']]}")
    for child in node.children:
        matches.extend(check_antipatterns(child, antipatterns, []))
    return matches

# Temp Subtree matching
# def check_subtree_match(docker_node, antipattern_node):
#     """Recursively checks if a subtree of Dockerfile matches the subtree of an antipattern."""
#     # Check the current node match
#     if docker_node.instruction != antipattern_node['instruction'] or antipattern_node['args'] not in docker_node.args:
#         return False

#     # If additional properties are to be checked (like 'user')
#     if 'user' in antipattern_node and (
#         (antipattern_node['user'] is False and docker_node.user != '') or
#         (antipattern_node['user'] is True and docker_node.user == '')
#     ):
#         return False

#     # Check all children if they can match in any order
#     if len(antipattern_node['children']) != len(docker_node.children):
#         return False

#     # Use a list to track which antipattern children have been matched
#     matched = [False] * len(antipattern_node['children'])
#     for i, docker_child in enumerate(docker_node.children):
#         # Try to find a matching antipattern child that hasn't been matched yet
#         for j, antipattern_child in enumerate(antipattern_node['children']):
#             if not matched[j] and check_subtree_match(docker_child, antipattern_child):
#                 matched[j] = True
#                 break
#         else:
#             # If no matching child is found for this docker child, the subtree doesn't match
#             return False

#     return all(matched)

# def check_antipatterns(node, antipattern_trees, matches, error_descriptions):
#     """Checks if any subtree of the Dockerfile matches with any of the antipattern trees in the list."""
#     for antipattern_tree in antipattern_trees:
#         if check_subtree_match(node, antipattern_tree):
#             matches.append(f"Antipattern found: {error_descriptions[antipattern_tree['errorNo']]}")
#     for child in node.children:
#         check_antipatterns(child, antipattern_trees, matches, error_descriptions)
#     return matches


# Eski
# def check_for_vulnerabilities(node, patterns):
#     """Check for vulnerabilities based on patterns and instruction sequences."""
#     vulnerabilities = []
#     instructions = [child.instruction for child in node.children]
#     # args_map = {child.instruction: child.args for child in node.children}
#     # user_map = {child.instruction: child.user for child in node.children}

#     args_map = {}
#     for child in node.children:
#         if child.instruction in args_map:
#             args_map[child.instruction].append(child.args)
#         else:
#             args_map[child.instruction] = [child.args]

#     user_map = {}
#     for child in node.children:
#         if child.user in user_map:
#             user_map[child.instruction].append(child.user)
#         else:
#             user_map[child.instruction] = [child.user]
#     pprint(user_map)


#     # Check for single instruction vulnerabilities
#     for pattern in patterns:
#         if pattern['instruction'] in instructions and any(pattern['args'] in args for args in args_map[pattern['instruction']]):
#             if not 'user' in pattern:
#                 vulnerabilities.append(f"Vulnerability found: {error_descriptions[pattern['errorNo']]}")
#             elif pattern['user'] is False and not all(user_map[pattern['instruction']]): # Check for user not defined vulnerabilities
#                 vulnerabilities.append(f" Vulnerability found: {error_descriptions[pattern['errorNo']]}")

            
#     # Check for absence of critical instructions
#     if 'USER' not in instructions:
#         vulnerabilities.append("Vulnerability found: Container runs as root since there is no USER directive.")


#     return vulnerabilities


# Path to the Dockerfile
dockerfile_path = './Dockerfile'

# Parsing the Dockerfile
dockerfile_ast = parse_dockerfile(dockerfile_path)

# Checking for vulnerabilities
vulnerabilities = check_for_vulnerabilities(dockerfile_ast, patterns)
for vulnerability in vulnerabilities:
    print(vulnerability)
