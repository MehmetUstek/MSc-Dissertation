from compose.check_password import check_password_plaintext
from compose.missing_configurations import check_missing_configurations
from compose.parse_compose import (parse_yaml_to_ast,
                                   parse_yaml_to_ast_from_file_content)
from compose.shared_volume_vulnerabilities import \
    check_shared_volume_antipattern
from utils import fetch_vulnerability_detail, is_subset
from utils.load_json import load_json
from utils.logs.custom_formatter import logger_with_custom_formatter
from utils.logs.severity_printer import print_severity


def check_for_vulnerabilities(node, patterns, required_configurations,compose_error_descriptions):
    matches = []
    # Missing configurations
    check_missing_configurations(node, required_configurations, matches,compose_error_descriptions)
    # Check for shared volume antipatterns
    matches.extend(check_shared_volume_antipattern(node,compose_error_descriptions))
    # Base conditions
    check_compose_antipatterns(node, patterns, matches,compose_error_descriptions)

    if len(matches) >0:
        return matches
    else:
        return None

def check_ast_match(ast_node, pattern_node):
    """Recursively checks if an AST node matches the pattern node structure."""
    if isinstance(ast_node, dict) and isinstance(pattern_node, dict):
        return is_subset(pattern_node, ast_node)

    elif isinstance(pattern_node, dict):
        if isinstance(ast_node, list):
            for subnode in ast_node:
                # print(subnode)
                if check_ast_match(subnode, pattern_node):
                    return True
                # if pattern_node in subnode:
                #     return True

        # elif not isinstance(ast_node, dict):
        #     if any(key not in ast_node or not check_ast_match(ast_node[key], pattern_value) for key, pattern_value in pattern_node.items()):
        #         return False
        #### TODO: Bunun ne olduğunu hatırlamıyorum ama kullanmışım, çok acil inceleme lazım


    elif isinstance(pattern_node, list):
        # if not isinstance(ast_node, list) or len(pattern_node) != len(ast_node):
        #     return False
        if isinstance(ast_node, list):
            false_flag = True
            for ast_item, pattern_item in zip(ast_node, pattern_node):
                if not isinstance(pattern_item, int):
                    if "PASSWORD" in pattern_item and "PASSWORD" in ast_item:
                            if len(ast_item.split("=")) > 1:
                                _, password_text = ast_item.split("=")
                                if check_password_plaintext(password_text):
                                    return True
                if not check_ast_match(ast_item, pattern_item):
                    false_flag = False
                    return False
            if false_flag:
                return True
    
    elif isinstance(pattern_node, str):
        if isinstance(ast_node, str):
            return pattern_node in ast_node
    
    elif isinstance(pattern_node, int): # Booleans are also ints in python
        if isinstance(ast_node, str):
            return ast_node in str(pattern_node)
        elif isinstance(ast_node, int):
            return ast_node == pattern_node
    
    else:
        # This assumes pattern_node is a terminal value that must match exactly
        # print(",",pattern_node,ast_node)
        if isinstance(ast_node, bool):
            return ast_node == pattern_node
        
        if isinstance(ast_node, int):
            return ast_node == pattern_node
        
        
        return pattern_node in ast_node
        # return False
       
    # return True

def check_compose_antipatterns(ast, antipattern_trees, matches,compose_error_descriptions):
    """Checks if any part of the AST matches any of the antipattern trees."""
    if isinstance(ast, dict):
        for key, ast_subnode in ast.items():
            # print(key, ast_subnode)
            # print(antipattern_trees)
            for pattern in antipattern_trees:
                # print(pattern)
                if key in pattern and check_ast_match(ast_subnode, pattern[key]):
                    matches.append({"errorNo":str(pattern['errorNo']),"severity":pattern["severity"], "ast_subnode":ast_subnode, "key":key})
            check_compose_antipatterns(ast_subnode, antipattern_trees, matches,compose_error_descriptions)
    elif isinstance(ast, list):
        for item in ast:
            check_compose_antipatterns(item, antipattern_trees, matches,compose_error_descriptions)

    # elif isinstance(ast, str):
    #     print(ast)
    #     if check_ast_match(ast, pattern[key]):
    #         matches.append([f"Antipattern found in {key}:{ast_subnode}: {compose_error_descriptions[str(pattern['errorNo'])]}",pattern["severity"]])


    return matches

def output_vulnerabilities(filename, file_ast, isVerbose):
    # Load the configurations using the function
    patterns = load_json('compose/antipattern_trees.json')
    missing_configuration_patterns = load_json('compose/missing_configuration_trees.json')
    error_descriptions = load_json('compose/antipattern_descriptions.json')
    
    # Checking for vulnerabilities
    vulnerabilities = check_for_vulnerabilities(file_ast, patterns, missing_configuration_patterns, error_descriptions)
    if isVerbose and vulnerabilities:
        # Set logger
        logger = logger_with_custom_formatter(file_path=filename)
        for vulnerability in vulnerabilities:
            vulnerability_detail = fetch_vulnerability_detail(error_descriptions=error_descriptions, errorNo=vulnerability.get("errorNo"), custom_error_message=vulnerability.get("customErrorMessage"),isdockerfile=False,is_missing_configuration=vulnerability.get("is_missing_configuration"), key=vulnerability.get("key"), ast_subnode=vulnerability.get("ast_subnode"))
            print_severity(logger, vulnerability["severity"], vulnerability_detail)
    
    return vulnerabilities


def get_compose_file_vulnerabilities(file_path, isVerbose=True):
    try:
        # Parsing the Dockerfile
        file_ast = parse_yaml_to_ast(file_path)
        if file_ast == None:
            raise RuntimeError("The provided file cannot be parsed. Possible syntax issue within the file")
        # Load the Error and Pattern Files.
        return output_vulnerabilities(filename=file_path,file_ast=file_ast, isVerbose=isVerbose)
    except Exception as e:
        raise


def get_compose_file_vulnerabilities_filecontent(fileContent, filename, isVerbose=True):
    try:
        # Parsing the Dockerfile
        file_ast = parse_yaml_to_ast_from_file_content(fileContent)
        if file_ast == None:
            raise RuntimeError("The provided file cannot be parsed. Possible syntax issue within the file")
        # Load the Error and Pattern Files.
        return output_vulnerabilities(file_ast=file_ast, filename=filename, isVerbose=isVerbose)
    except Exception as e:
        raise



# Path to the Compose File
# compose_file_path = './compose_temp.yml'

# get_compose_file_vulnerabilities(compose_file_path)