import logging
from antipattern_descriptions import compose_error_descriptions
from load_configuration import load_configuration
from missing_configurations import check_missing_configurations
from shared_volume_vulnerabilities import check_shared_volume_antipattern
from parse_compose import parse_yaml_to_ast
import sys
sys.path.append("..")

from logs.custom_formatter import CustomFormatter
from logs.severity_printer import print_severity


def check_for_vulnerabilities(node, patterns, required_configurations):
    matches = []
    # Missing configurations
    check_missing_configurations(node, required_configurations, matches)

    # Check for shared volume antipatterns
    check_shared_volume_antipattern(node, matches)

    # Base conditions
    check_compose_antipatterns(node, patterns, matches)
    return matches

def check_ast_match(ast_node, pattern_node):
    """Recursively checks if an AST node matches the pattern node structure."""
    if isinstance(pattern_node, dict):
        if not isinstance(ast_node, dict) or any(key not in ast_node or not check_ast_match(ast_node[key], pattern_value) for key, pattern_value in pattern_node.items()):
            return False
    elif isinstance(pattern_node, list):
        # if not isinstance(ast_node, list) or len(pattern_node) != len(ast_node):
        #     return False
        if isinstance(ast_node, list):
            for ast_item, pattern_item in zip(ast_node, pattern_node):
                if not check_ast_match(ast_item, pattern_item):
                    return False
    else:
        # This assumes pattern_node is a terminal value that must match exactly
        return pattern_node in ast_node
    return True

def check_compose_antipatterns(ast, antipattern_trees, matches):
    """Checks if any part of the AST matches any of the antipattern trees."""
    if isinstance(ast, dict):
        for key, ast_subnode in ast.items():
            for pattern in antipattern_trees:
                if key in pattern and check_ast_match(ast_subnode, pattern[key]):
                    matches.append([f"Antipattern found in {key}: {compose_error_descriptions[pattern['errorNo']]}",9])
            check_compose_antipatterns(ast_subnode, antipattern_trees, matches)
    elif isinstance(ast, list):
        for item in ast:
            check_compose_antipatterns(item, antipattern_trees, matches)

    return matches



# Path to the Compose File
dockerfile_path = './compose_temp.yml'

# create logger
logger = logging.getLogger(dockerfile_path)
logger.setLevel(logging.DEBUG)

# create console handler with a higher log level
ch = logging.StreamHandler()
ch.setLevel(logging.DEBUG)

ch.setFormatter(CustomFormatter())

logger.addHandler(ch)

# Load the configurations using the function
patterns = load_configuration('antipattern_trees.json')
required_configurations = load_configuration('missing_configuration_trees.json')

# Parsing the Dockerfile
dockerfile_ast = parse_yaml_to_ast(dockerfile_path)

# Checking for vulnerabilities
vulnerabilities = check_for_vulnerabilities(dockerfile_ast, patterns, required_configurations)
for vulnerability, severity in vulnerabilities:
    print_severity(logger, severity, vulnerability)
