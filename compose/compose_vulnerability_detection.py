from compose.missing_configurations import check_missing_configurations
from compose.shared_volume_vulnerabilities import check_shared_volume_antipattern
from compose.parse_compose import parse_yaml_to_ast
from compose.check_password import check_password_plaintext
from utils import is_subset,fetch_vulnerability_detail
from utils.logs.custom_formatter import logger_with_custom_formatter
from utils.logs.severity_printer import print_severity
from utils.load_json import load_json



def check_for_vulnerabilities(node, patterns, required_configurations,compose_error_descriptions):
    matches = []
    # Missing configurations
    check_missing_configurations(node, required_configurations, matches,compose_error_descriptions)
    # Check for shared volume antipatterns
    matches.extend(check_shared_volume_antipattern(node,compose_error_descriptions))

    # Base conditions
    check_compose_antipatterns(node, patterns, matches,compose_error_descriptions)
    return matches

def check_ast_match(ast_node, pattern_node):
    """Recursively checks if an AST node matches the pattern node structure."""
    if isinstance(ast_node, dict) and isinstance(pattern_node, dict):
        return is_subset(pattern_node, ast_node)

    elif isinstance(pattern_node, dict):
        if isinstance(ast_node, list):
            for subnode in ast_node:
                print(subnode)
                if check_ast_match(subnode, pattern_node):
                    return True
                # if pattern_node in subnode:
                #     return True

        # elif not isinstance(ast_node, dict):
        #     if any(key not in ast_node or not check_ast_match(ast_node[key], pattern_value) for key, pattern_value in pattern_node.items()):
        #         return False
        #### TODO: Bunun ne olduğunu hatırlamıyorum ama kullanmışım, çok acil inceleme lazım


    elif isinstance(pattern_node, list):
        # if not isinstance(ast_node, list) or len(pattern_node) != len(ast_node):
        #     return False
        if isinstance(ast_node, list):
            false_flag = True
            for ast_item, pattern_item in zip(ast_node, pattern_node):
                if not isinstance(pattern_item, int):
                    if "PASSWORD" in pattern_item and "PASSWORD" in ast_item:
                            if len(ast_item.split("=")) > 1:
                                _, password_text = ast_item.split("=")
                                if check_password_plaintext(password_text):
                                    return True
                if not check_ast_match(ast_item, pattern_item):
                    false_flag = False
                    return False
            if false_flag:
                return True
    
    elif isinstance(pattern_node, str):
        if isinstance(ast_node, str):
            return ast_node in pattern_node
    
    elif isinstance(pattern_node, int):
        if isinstance(ast_node, str):
            return ast_node in str(pattern_node)
    
    else:
        # This assumes pattern_node is a terminal value that must match exactly
        # print(",",pattern_node,ast_node)
        if isinstance(ast_node, bool):
            return ast_node == pattern_node
        
        if isinstance(ast_node, int):
            return ast_node == pattern_node
        
        
        return pattern_node in ast_node
        # return False
       
    # return True

def check_compose_antipatterns(ast, antipattern_trees, matches,compose_error_descriptions):
    """Checks if any part of the AST matches any of the antipattern trees."""
    if isinstance(ast, dict):
        for key, ast_subnode in ast.items():
            # print(key, ast_subnode)
            # print(antipattern_trees)
            for pattern in antipattern_trees:
                # print(pattern)
                if key in pattern and check_ast_match(ast_subnode, pattern[key]):
                    matches.append({"errorNo":str(pattern['errorNo']),"severity":pattern["severity"], "ast_subnode":ast_subnode, "key":key})
            check_compose_antipatterns(ast_subnode, antipattern_trees, matches,compose_error_descriptions)
    elif isinstance(ast, list):
        for item in ast:
            check_compose_antipatterns(item, antipattern_trees, matches,compose_error_descriptions)

    # elif isinstance(ast, str):
    #     print(ast)
    #     if check_ast_match(ast, pattern[key]):
    #         matches.append([f"Antipattern found in {key}:{ast_subnode}: {compose_error_descriptions[str(pattern['errorNo'])]}",pattern["severity"]])


    return matches


def get_compose_file_vulnerabilities(compose_file_path, isVerbose):
    # Set logger
    logger = logger_with_custom_formatter(file_path=compose_file_path)

    # Load the configurations using the function
    patterns = load_json('compose/antipattern_trees.json')
    required_configurations = load_json('compose/missing_configuration_trees.json')
    compose_error_descriptions = load_json('compose/antipattern_descriptions.json')
    

    # Parsing the Dockerfile
    dockerfile_ast = parse_yaml_to_ast(compose_file_path)

    # Checking for vulnerabilities
    vulnerabilities = check_for_vulnerabilities(dockerfile_ast, patterns, required_configurations,compose_error_descriptions)
    if isVerbose:
        for vulnerability in vulnerabilities:
            vulnerability_detail = fetch_vulnerability_detail(error_descriptions=compose_error_descriptions, errorNo=vulnerability.get("errorNo"), custom_error_message=vulnerability.get("customErrorMessage"),isdockerfile=False,is_missing_configuration=vulnerability.get("is_missing_configuration"), key=vulnerability.get("key"), ast_subnode=vulnerability.get("ast_subnode"))
            print_severity(logger, vulnerability["severity"], vulnerability_detail)
    
    return vulnerabilities


# Path to the Compose File
# compose_file_path = './compose_temp.yml'

# get_compose_file_vulnerabilities(compose_file_path)