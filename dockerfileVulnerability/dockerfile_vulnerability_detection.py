import re
from typing import List
from dockerfileVulnerability.parse_dockerfile import parse_dockerfile
from dockerfileVulnerability.dockerfile_node import DockerfileNode
from utils.logs.custom_formatter import logger_with_custom_formatter
from utils.logs.severity_printer import print_severity
from utils.load_json import load_json
from dockerfileVulnerability.outsource_image_vulnerability_scan import outsource_image_vulnerability_scan as image_vulnerability_scan


def check_for_vulnerabilities(node: DockerfileNode, patterns, error_descriptions):
    matches = []
    # Base conditions


    if not node.globalUser:
        matches.append(["Antipattern found: Container runs as root since there is no USER directive.",10])
    elif not node.is_user_added(node.globalUser):
        matches.append([f"Antipattern found: {error_descriptions['25']}",8])
    elif not node.get_group_from_user(node.globalUser):
        matches.append([f"Antipattern found: {error_descriptions['26']}",8])
    matches.extend(check_antipatterns(node, patterns,error_descriptions))
    matches.extend(image_vulnerability_scan(node.FROM))

    return matches


def append_to_antipattern_list(node, antipattern,matches, error_descriptions):
    if not 'user' in antipattern:
        matches.append([f"Antipattern found: on line {node.lineNo}: {error_descriptions[str(antipattern['errorNo'])]}", antipattern["severity"]])
    elif antipattern['user'] is False and node.user == '': # Check for user not defined vulnerabilities
        matches.append([f"Antipattern found: on line {node.lineNo}: {error_descriptions[str(antipattern['errorNo'])]}", antipattern["severity"]])

    
def check_antipatterns(node: DockerfileNode, antipatterns, error_descriptions):
    """Recursively check for antipatterns in the Dockerfile AST."""
    matches = []
    
    for antipattern in antipatterns:
        # print(antipattern)
        if not "isRegexOfForm" in antipattern:
            if node.instruction == antipattern['instruction'] and antipattern['args'] in node.args:
                append_to_antipattern_list(node,antipattern, matches, error_descriptions)
        else:
            # isRegexOfForm is specified
            if not antipattern["isRegexOfForm"]:
                match = re.search(antipattern['args'], node.args)
                # isRegexOfForm is false - not specified - and a match is not found in the regex.
                if node.instruction == antipattern['instruction'] and not match:
                    append_to_antipattern_list(node,antipattern, matches, error_descriptions)
            # else:
            #     if not (node.instruction == antipattern['instruction'] and antipattern['args'] in node.args):
            #         append_to_antipattern_list(node,antipattern, matches, error_descriptions)

    for child in node.children:
        matches.extend(check_antipatterns(child, antipatterns,error_descriptions))
    return matches

# Temp Subtree matching
# def check_subtree_match(docker_node, antipattern_node):
#     """Recursively checks if a subtree of Dockerfile matches the subtree of an antipattern."""
#     # Check the current node match
#     if docker_node.instruction != antipattern_node['instruction'] or antipattern_node['args'] not in docker_node.args:
#         return False

#     # If additional properties are to be checked (like 'user')
#     if 'user' in antipattern_node and (
#         (antipattern_node['user'] is False and docker_node.user != '') or
#         (antipattern_node['user'] is True and docker_node.user == '')
#     ):
#         return False

#     # Check all children if they can match in any order
#     if len(antipattern_node['children']) != len(docker_node.children):
#         return False

#     # Use a list to track which antipattern children have been matched
#     matched = [False] * len(antipattern_node['children'])
#     for i, docker_child in enumerate(docker_node.children):
#         # Try to find a matching antipattern child that hasn't been matched yet
#         for j, antipattern_child in enumerate(antipattern_node['children']):
#             if not matched[j] and check_subtree_match(docker_child, antipattern_child):
#                 matched[j] = True
#                 break
#         else:
#             # If no matching child is found for this docker child, the subtree doesn't match
#             return False

#     return all(matched)

# def check_antipatterns(node, antipattern_trees, matches, error_descriptions):
#     """Checks if any subtree of the Dockerfile matches with any of the antipattern trees in the list."""
#     for antipattern_tree in antipattern_trees:
#         if check_subtree_match(node, antipattern_tree):
#             matches.append(f"Antipattern found: {error_descriptions[antipattern_tree['errorNo']]}")
#     for child in node.children:
#         check_antipatterns(child, antipattern_trees, matches, error_descriptions)
#     return matches


def get_dockerfile_vulnerabilities(dockerfile_path):
    logger = logger_with_custom_formatter(dockerfile_path=dockerfile_path)
    # Parsing the Dockerfile
    dockerfile_ast = parse_dockerfile(dockerfile_path)

    error_descriptions = load_json('dockerfileVulnerability/antipattern_descriptions.json')
    patterns = load_json('dockerfileVulnerability/pattern_data.json')


    # Checking for vulnerabilities
    
    vulnerabilities = check_for_vulnerabilities(dockerfile_ast, patterns, error_descriptions)
    for vulnerability, severity in vulnerabilities:
        print_severity(logger, severity, vulnerability)


# Path to the Dockerfile
# dockerfile_path = './Dockerfile'
# get_dockerfile_vulnerabilities(dockerfile_path)



