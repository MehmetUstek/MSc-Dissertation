from typing import List
from dockerfileVulnerability.parse_dockerfile import parse_dockerfile
import sys
sys.path.append("..")
from dockerfileVulnerability.dockerfile_node import DockerfileNode
from utils.logs.custom_formatter import logger_with_custom_formatter
from utils.logs.severity_printer import print_severity
from utils.load_json import load_json


def check_for_vulnerabilities(node, patterns,error_descriptions):
    matches = []
    # Base conditions
    instructions = [child.instruction for child in node.children]
    if 'USER' not in instructions:
        matches.append(["Vulnerability found: Container runs as root since there is no USER directive.",10])
    matches.extend(check_antipatterns(node, patterns,error_descriptions))
    return matches
    
def check_antipatterns(node, antipatterns, error_descriptions):
    """Recursively check for antipatterns in the Dockerfile AST."""
    matches = []
    
    for antipattern in antipatterns:
        # print(antipattern)
        if node.instruction == antipattern['instruction'] and antipattern['args'] in node.args:
            if not 'user' in antipattern:
                matches.append([f"Antipattern found: {error_descriptions[str(antipattern['errorNo'])]}", antipattern["severity"]])
            elif antipattern['user'] is False and node.user == '': # Check for user not defined vulnerabilities
                matches.append([f"Antipattern found: {error_descriptions[str(antipattern['errorNo'])]}", antipattern["severity"]])
    for child in node.children:
        matches.extend(check_antipatterns(child, antipatterns,error_descriptions))
    return matches

# Temp Subtree matching
# def check_subtree_match(docker_node, antipattern_node):
#     """Recursively checks if a subtree of Dockerfile matches the subtree of an antipattern."""
#     # Check the current node match
#     if docker_node.instruction != antipattern_node['instruction'] or antipattern_node['args'] not in docker_node.args:
#         return False

#     # If additional properties are to be checked (like 'user')
#     if 'user' in antipattern_node and (
#         (antipattern_node['user'] is False and docker_node.user != '') or
#         (antipattern_node['user'] is True and docker_node.user == '')
#     ):
#         return False

#     # Check all children if they can match in any order
#     if len(antipattern_node['children']) != len(docker_node.children):
#         return False

#     # Use a list to track which antipattern children have been matched
#     matched = [False] * len(antipattern_node['children'])
#     for i, docker_child in enumerate(docker_node.children):
#         # Try to find a matching antipattern child that hasn't been matched yet
#         for j, antipattern_child in enumerate(antipattern_node['children']):
#             if not matched[j] and check_subtree_match(docker_child, antipattern_child):
#                 matched[j] = True
#                 break
#         else:
#             # If no matching child is found for this docker child, the subtree doesn't match
#             return False

#     return all(matched)

# def check_antipatterns(node, antipattern_trees, matches, error_descriptions):
#     """Checks if any subtree of the Dockerfile matches with any of the antipattern trees in the list."""
#     for antipattern_tree in antipattern_trees:
#         if check_subtree_match(node, antipattern_tree):
#             matches.append(f"Antipattern found: {error_descriptions[antipattern_tree['errorNo']]}")
#     for child in node.children:
#         check_antipatterns(child, antipattern_trees, matches, error_descriptions)
#     return matches


# Eski
# def check_for_vulnerabilities(node, patterns):
#     """Check for vulnerabilities based on patterns and instruction sequences."""
#     vulnerabilities = []
#     instructions = [child.instruction for child in node.children]
#     # args_map = {child.instruction: child.args for child in node.children}
#     # user_map = {child.instruction: child.user for child in node.children}

#     args_map = {}
#     for child in node.children:
#         if child.instruction in args_map:
#             args_map[child.instruction].append(child.args)
#         else:
#             args_map[child.instruction] = [child.args]

#     user_map = {}
#     for child in node.children:
#         if child.user in user_map:
#             user_map[child.instruction].append(child.user)
#         else:
#             user_map[child.instruction] = [child.user]
#     pprint(user_map)


#     # Check for single instruction vulnerabilities
#     for pattern in patterns:
#         if pattern['instruction'] in instructions and any(pattern['args'] in args for args in args_map[pattern['instruction']]):
#             if not 'user' in pattern:
#                 vulnerabilities.append(f"Vulnerability found: {error_descriptions[pattern['errorNo']]}")
#             elif pattern['user'] is False and not all(user_map[pattern['instruction']]): # Check for user not defined vulnerabilities
#                 vulnerabilities.append(f" Vulnerability found: {error_descriptions[pattern['errorNo']]}")

            
#     # Check for absence of critical instructions
#     if 'USER' not in instructions:
#         vulnerabilities.append("Vulnerability found: Container runs as root since there is no USER directive.")


#     return vulnerabilities

def get_dockerfile_vulnerabilities(dockerfile_path):
    logger = logger_with_custom_formatter(dockerfile_path=dockerfile_path)
    # Parsing the Dockerfile
    dockerfile_ast = parse_dockerfile(dockerfile_path)

    error_descriptions = load_json('dockerfileVulnerability/antipattern_descriptions.json')
    patterns = load_json('dockerfileVulnerability/pattern_data.json')


    # Checking for vulnerabilities
    vulnerabilities = check_for_vulnerabilities(dockerfile_ast, patterns,error_descriptions)
    for vulnerability, severity in vulnerabilities:
        print_severity(logger, severity, vulnerability)



# Path to the Dockerfile
# dockerfile_path = './Dockerfile'
# get_dockerfile_vulnerabilities(dockerfile_path)



